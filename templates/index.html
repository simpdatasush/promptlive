<!DOCTYPE html>
<html>
<head>
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <title>Lexi Web</title>
    <style>
        body { background: #000; color: #00fdff; font-family: 'Courier New', monospace; text-align: center; }
        #chat-box { width: 80%; max-width: 600px; height: 400px; margin: 20px auto; border: 1px solid #00fdff; overflow-y: auto; padding: 15px; background: #050505; }
        input { width: 80%; max-width: 600px; background: #111; border: 1px solid #00fdff; color: #00fdff; padding: 15px; font-size: 1.1em; }
        .user-msg { color: #fff; margin: 5px 0; }
        .lexi-msg { color: #00fdff; margin: 5px 0; font-weight: bold; }
    </style>
</head>
<body>
    <h1>LEXI v5 LIVE</h1>
    <div id="chat-box"></div>
    <input type="text" id="userInput" placeholder="Ask Lexi something...">

    <script>
    const chatBox = document.getElementById('chat-box');
    const input = document.getElementById('userInput');
    let currentLexiBubble = null; // Tracks the current active Lexi bubble

    // DYNAMIC PROTOCOL DETECTION
    const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
    const socket = new WebSocket(`${protocol}${window.location.host}/ws`);

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });

    socket.onopen = () => console.log("Connected to Lexi via", protocol);

    socket.onmessage = async (event) => {
        const msg = JSON.parse(event.data);
        
        if (msg.type === "text") {
            // If Lexi hasn't started a bubble for this turn yet, create one
            if (!currentLexiBubble) {
                currentLexiBubble = createChatBubble("Lexi", "lexi-msg");
            }
            // Append the new text chunk to the existing span
            currentLexiBubble.querySelector('.msg-content').innerText += msg.data;
            chatBox.scrollTop = chatBox.scrollHeight;
        }
        
        if (msg.type === "audio") {
            playPCM(msg.data);
        }
    };

    input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && input.value.trim() !== "") {
            socket.send(JSON.stringify({ type: "text", data: input.value }));
            
            // 1. Create User Bubble
            const userBubble = createChatBubble("You", "user-msg");
            userBubble.querySelector('.msg-content').innerText = input.value;
            
            // 2. IMPORTANT: Reset Lexi's bubble so her next reply starts fresh
            currentLexiBubble = null;
            
            input.value = "";
            chatBox.scrollTop = chatBox.scrollHeight;
        }
    });

    // New helper function to create structured bubbles
    function createChatBubble(sender, className) {
        const div = document.createElement('div');
        div.className = className;
        div.style.marginBottom = "10px";
        
        // Structure: "Sender: [Content]"
        div.innerHTML = `<strong>${sender}:</strong> <span class="msg-content"></span>`;
        
        chatBox.appendChild(div);
        return div;
    }

    async function playPCM(base64Data) {
        const arrayBuffer = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0)).buffer;
        const float32Data = new Float32Array(arrayBuffer.byteLength / 2);
        const int16Data = new Int16Array(arrayBuffer);
        for (let i = 0; i < int16Data.length; i++) float32Data[i] = int16Data[i] / 32768.0;
        const buffer = audioCtx.createBuffer(1, float32Data.length, 24000);
        buffer.getChannelData(0).set(float32Data);
        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.connect(audioCtx.destination);
        source.start();
    }
</script>
</body>
</html>
